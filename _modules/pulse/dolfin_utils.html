

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pulse.dolfin_utils &mdash; pulse 2020.2.2 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pulse
          

          
          </a>

          
            
            
              <div class="version">
                2020.2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Demos</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../demos/demos.html">Demos</a></li>
</ul>
<p class="caption"><span class="caption-text">Programmers reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pulse</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pulse</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../pulse.html">pulse</a> &raquo;</li>
        
      <li>pulse.dolfin_utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pulse.dolfin_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">dolfin</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">dolfin_adjoint</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Constant</span><span class="p">,</span>
        <span class="n">Function</span><span class="p">,</span>
        <span class="n">FunctionAssigner</span><span class="p">,</span>
        <span class="n">assemble</span><span class="p">,</span>
        <span class="n">interpolate</span><span class="p">,</span>
        <span class="n">project</span><span class="p">,</span>
    <span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Function</span><span class="p">,</span>
        <span class="n">interpolate</span><span class="p">,</span>
        <span class="n">Constant</span><span class="p">,</span>
        <span class="n">project</span><span class="p">,</span>
        <span class="n">assemble</span><span class="p">,</span>
        <span class="n">FunctionAssigner</span><span class="p">,</span>
    <span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">numpy_mpi</span><span class="p">,</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">DOLFIN_VERSION_MAJOR</span><span class="p">,</span> <span class="n">getLogger</span><span class="p">,</span> <span class="n">mpi_comm_world</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="map_vector_field"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.map_vector_field">[docs]</a><span class="k">def</span> <span class="nf">map_vector_field</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">new_mesh</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fiber&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a vector field (f0) onto a new mesh (new_mesh) where the new mesh</span>
<span class="sd">    can be a moved version of the original one according to some</span>
<span class="sd">    displacement (u). In that case we will just a Piola transform to</span>
<span class="sd">    map the vector field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">representation</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;representation&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">DOLFIN_VERSION_MAJOR</span> <span class="o">&gt;</span> <span class="mi">2016</span><span class="p">:</span>
        <span class="n">dolfin</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;quadrature&quot;</span>

    <span class="n">dolfin</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;quadrature_degree&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="n">ufl_elem</span> <span class="o">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
    <span class="n">f0_new</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">new_mesh</span><span class="p">,</span> <span class="n">ufl_elem</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">f0_mesh</span> <span class="o">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
        <span class="n">u_elm</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">f0_mesh</span><span class="p">,</span> <span class="n">u_elm</span><span class="p">)</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="c1"># arr = numpy_mpi.gather_vector(u.vector())</span>
        <span class="c1"># numpy_mpi.assign_to_vector(u0.vector(), arr)</span>
        <span class="n">u0</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.kinematics</span> <span class="kn">import</span> <span class="n">DeformationGradient</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">DeformationGradient</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>

        <span class="n">f0_updated</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">F</span> <span class="o">*</span> <span class="n">f0</span><span class="p">,</span> <span class="n">f0</span><span class="o">.</span><span class="n">function_space</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">f0_updated</span> <span class="o">=</span> <span class="n">normalize_vector_field</span><span class="p">(</span><span class="n">f0_updated</span><span class="p">)</span>

        <span class="n">f0_new</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">f0_updated</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
        <span class="c1"># f0_arr = numpy_mpi.gather_vector(f0_updated.vector())</span>
        <span class="c1"># numpy_mpi.assign_to_vector(f0_new.vector(), f0_arr)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># f0_arr = numpy_mpi.gather_vector(f0.vector())</span>
        <span class="c1"># numpy_mpi.assign_to_vector(f0_new.vector(), f0_arr)</span>
        <span class="n">f0_new</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">DOLFIN_VERSION_MAJOR</span> <span class="o">&gt;</span> <span class="mi">2016</span><span class="p">:</span>
        <span class="n">dolfin</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">representation</span>

    <span class="k">return</span> <span class="n">f0_new</span></div>


<div class="viewcode-block" id="update_function"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.update_function">[docs]</a><span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a function :math:`f` defined on some domain,</span>
<span class="sd">    update the function so that it now is defined on the domain</span>
<span class="sd">    given in the mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">f_new</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()))</span>
    <span class="n">numpy_mpi</span><span class="o">.</span><span class="n">assign_to_vector</span><span class="p">(</span><span class="n">f_new</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">numpy_mpi</span><span class="o">.</span><span class="n">gather_vector</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">vector</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">f_new</span></div>


<div class="viewcode-block" id="normalize_vector_field"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.normalize_vector_field">[docs]</a><span class="k">def</span> <span class="nf">normalize_vector_field</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a vector field, return a vector field with an L2 norm equal to 1.0&quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">()</span>

    <span class="n">components</span> <span class="o">=</span> <span class="n">vectorfield_to_components</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

    <span class="n">normarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="s2">&quot;l2&quot;</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
        <span class="n">comp</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">/</span> <span class="n">normarray</span>

    <span class="n">assigners</span> <span class="o">=</span> <span class="p">[</span><span class="n">FunctionAssigner</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">S</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">assigner</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">components</span><span class="p">,</span> <span class="n">assigners</span><span class="p">):</span>
        <span class="n">assigner</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">i</span><span class="p">],</span> <span class="n">comp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">u</span></div>


<div class="viewcode-block" id="vectorfield_to_components"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.vectorfield_to_components">[docs]</a><span class="k">def</span> <span class="nf">vectorfield_to_components</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">Function</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
    <span class="n">assigners</span> <span class="o">=</span> <span class="p">[</span><span class="n">FunctionAssigner</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">assigner</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">components</span><span class="p">,</span> <span class="n">assigners</span><span class="p">):</span>
        <span class="n">assigner</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">components</span></div>


<div class="viewcode-block" id="get_pressure"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_pressure">[docs]</a><span class="k">def</span> <span class="nf">get_pressure</span><span class="p">(</span><span class="n">problem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns p_lv (and p_rv if BiV mesh)&quot;&quot;&quot;</span>

    <span class="n">plv</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">traction</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">problem</span><span class="o">.</span><span class="n">bcs</span><span class="o">.</span><span class="n">neumann</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;lv&quot;</span><span class="p">]</span>
    <span class="n">prv</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">traction</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">problem</span><span class="o">.</span><span class="n">bcs</span><span class="o">.</span><span class="n">neumann</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;rv&quot;</span><span class="p">]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">plv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Problem has no Neumann BC for LV endo&quot;</span>
    <span class="n">pressure</span> <span class="o">=</span> <span class="p">[</span><span class="n">plv</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">prv</span><span class="p">:</span>
        <span class="n">pressure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pressure</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pressure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="read_hdf5"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.read_hdf5">[docs]</a><span class="k">def</span> <span class="nf">read_hdf5</span><span class="p">(</span><span class="n">h5name</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">h5group</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">mpi_comm_world</span><span class="p">()):</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">HDF5File</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">h5name</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5file</span><span class="p">:</span>

            <span class="n">h5file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">h5group</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Make sure file </span><span class="si">{}</span><span class="s2"> exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5name</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">ex</span>

    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">errro</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;Something went wrong when reading file &quot;</span>
                <span class="s2">&quot;</span><span class="si">{h5name}</span><span class="s2"> into function </span><span class="si">{func}</span><span class="s2"> from group &quot;</span>
                <span class="s2">&quot;</span><span class="si">{h5group}</span><span class="s2">&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5name</span><span class="o">=</span><span class="n">h5name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">h5group</span><span class="o">=</span><span class="n">h5group</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">ex</span></div>


<div class="viewcode-block" id="map_displacement"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.map_displacement">[docs]</a><span class="k">def</span> <span class="nf">map_displacement</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">old_space</span><span class="p">,</span> <span class="n">new_space</span><span class="p">,</span> <span class="n">approx</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;mapped displacement&quot;</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">approx</span> <span class="o">==</span> <span class="s2">&quot;interpolate&quot;</span><span class="p">:</span>
        <span class="c1"># Do we need dolfin-adjoint here or is dolfin enough?</span>
        <span class="n">u_int</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">old_space</span><span class="p">),</span> <span class="n">new_space</span><span class="p">)</span>  <span class="c1"># , name=name)</span>

    <span class="k">elif</span> <span class="n">approx</span> <span class="o">==</span> <span class="s2">&quot;project&quot;</span><span class="p">:</span>
        <span class="c1"># Do we need dolfin-adjoint here or is dolfin enough?</span>
        <span class="n">u_int</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">new_space</span><span class="p">)</span>  <span class="c1"># , name=name)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">u_int</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">return</span> <span class="n">u_int</span></div>


<div class="viewcode-block" id="compute_meshvolume"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.compute_meshvolume">[docs]</a><span class="k">def</span> <span class="nf">compute_meshvolume</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dolfin</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">subdomain_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Constant</span><span class="p">(</span>
        <span class="n">dolfin</span><span class="o">.</span><span class="n">assemble</span><span class="p">(</span>
            <span class="n">dolfin</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">subdomain_id</span><span class="o">=</span><span class="n">subdomain_id</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_cavity_volume"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_cavity_volume">[docs]</a><span class="k">def</span> <span class="nf">get_cavity_volume</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">unload</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chamber</span><span class="o">=</span><span class="s2">&quot;lv&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xshift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">unload</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">original_geometry</span>
        <span class="n">ffun</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">domains</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">ffun</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">ffun</span>

    <span class="k">if</span> <span class="n">chamber</span> <span class="o">==</span> <span class="s2">&quot;lv&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;ENDO_LV&quot;</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">markers</span><span class="p">:</span>
            <span class="n">endo_marker</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">markers</span><span class="p">[</span><span class="s2">&quot;ENDO_LV&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endo_marker</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">markers</span><span class="p">[</span><span class="s2">&quot;ENDO&quot;</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">endo_marker</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">markers</span><span class="p">[</span><span class="s2">&quot;ENDO_RV&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endo_marker</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">endo_marker</span> <span class="o">=</span> <span class="n">endo_marker</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="s2">&quot;exterior_facet&quot;</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">ffun</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">)(</span><span class="n">endo_marker</span><span class="p">)</span>

    <span class="n">vol_form</span> <span class="o">=</span> <span class="n">get_cavity_volume_form</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">xshift</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">assemble</span><span class="p">(</span><span class="n">vol_form</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_cavity_volume_form"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_cavity_volume_form">[docs]</a><span class="k">def</span> <span class="nf">get_cavity_volume_form</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xshift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">kinematics</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">((</span><span class="n">xshift</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">-</span> <span class="n">shift</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vol_form</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">kinematics</span><span class="o">.</span><span class="n">DeformationGradient</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">kinematics</span><span class="o">.</span><span class="n">Jacobian</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="n">vol_form</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">u</span><span class="p">,</span> <span class="n">J</span> <span class="o">*</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vol_form</span></div>


<div class="viewcode-block" id="get_constant"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_constant">[docs]</a><span class="k">def</span> <span class="nf">get_constant</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">value_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value_rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="n">Constant</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Constant</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">Function</span><span class="p">)):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">numpy_mpi</span><span class="o">.</span><span class="n">gather_vector</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">constant</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">GenericVector</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">numpy_mpi</span><span class="o">.</span><span class="n">gather_vector</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constant</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">value_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">value_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
                <span class="c1"># Hope for the best</span>
                <span class="n">value_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">value_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">constant</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">constant</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">constant</span><span class="p">([</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">value_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="get_dimesion"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_dimesion">[docs]</a><span class="k">def</span> <span class="nf">get_dimesion</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>

    <span class="c1"># TODO : Check argument</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">DOLFIN_VERSION_MAJOR</span> <span class="o">&gt;</span> <span class="mf">1.6</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ufl.domain</span> <span class="kn">import</span> <span class="n">find_geometric_dimension</span>

            <span class="n">dim</span> <span class="o">=</span> <span class="n">find_geometric_dimension</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">geometric_dimension</span><span class="p">()</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex2</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">ex2</span><span class="p">)</span>
            <span class="c1"># Assume dimension is 3</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Assume dimension is 3&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">return</span> <span class="n">dim</span></div>


<div class="viewcode-block" id="subplus"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.subplus">[docs]</a><span class="k">def</span> <span class="nf">subplus</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ramp function</span>

<span class="sd">    .. math::</span>

<span class="sd">       \max\{x,0\}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="heaviside"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.heaviside">[docs]</a><span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Heaviside function</span>

<span class="sd">    .. math::</span>

<span class="sd">       \frac{\mathrm{d}}{\mathrm{d}x} \max\{x,0\}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="list_sum"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.list_sum">[docs]</a><span class="k">def</span> <span class="nf">list_sum</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum of a list, when the convetiional</span>
<span class="sd">    method (like `sum`) it not working.</span>
<span class="sd">    For example if you have a list of dolfin functions.</span>

<span class="sd">    :param list l: a list of objects</span>
<span class="sd">    :returns: The sum of the list. The type depends on</span>
<span class="sd">              the type of elemets in the list</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="get_spaces"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.get_spaces">[docs]</a><span class="k">def</span> <span class="nf">get_spaces</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an object of dolfin FunctionSpace, to</span>
<span class="sd">    be used in the optimization pipeline</span>

<span class="sd">    :param mesh: The mesh</span>
<span class="sd">    :type mesh: :py:class:`dolfin.Mesh`</span>
<span class="sd">    :returns: An object of functionspaces</span>
<span class="sd">    :rtype: object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make a dummy object</span>
    <span class="n">spaces</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Object</span><span class="p">()</span>

    <span class="c1"># A real space with scalars used for dolfin adjoint</span>
    <span class="n">spaces</span><span class="o">.</span><span class="n">r_space</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># A space for the strain fields</span>
    <span class="n">spaces</span><span class="o">.</span><span class="n">strainfieldspace</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># A space used for scalar strains</span>
    <span class="n">spaces</span><span class="o">.</span><span class="n">strainspace</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Spaces for the strain weights</span>
    <span class="n">spaces</span><span class="o">.</span><span class="n">strain_weight_space</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">TensorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spaces</span></div>


<div class="viewcode-block" id="QuadratureSpace"><a class="viewcode-back" href="../../pulse.html#pulse.dolfin_utils.QuadratureSpace">[docs]</a><span class="k">def</span> <span class="nf">QuadratureSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From FEniCS version 1.6 to 2016.1 there was a change in how</span>
<span class="sd">    FunctionSpace is defined for quadrature spaces.</span>
<span class="sd">    This functions checks your dolfin version and returns the correct</span>
<span class="sd">    quadrature space</span>

<span class="sd">    :param mesh: The mesh</span>
<span class="sd">    :type mesh: :py:class:`dolfin.Mesh`</span>
<span class="sd">    :param int degree: The degree of the element</span>
<span class="sd">    :param int dim: For a mesh of topological dimension 3,</span>
<span class="sd">                    dim = 1 would be a scalar function, and</span>
<span class="sd">                    dim = 3 would be a vector function.</span>
<span class="sd">    :returns: The quadrature space</span>
<span class="sd">    :rtype: :py:class:`dolfin.FunctionSpace`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">DOLFIN_VERSION_MAJOR</span> <span class="o">&gt;</span> <span class="mf">1.6</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FiniteElement</span><span class="p">(</span>
                <span class="n">family</span><span class="o">=</span><span class="s2">&quot;Quadrature&quot;</span><span class="p">,</span>
                <span class="n">cell</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span>
                <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                <span class="n">quad_scheme</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorElement</span><span class="p">(</span>
                <span class="n">family</span><span class="o">=</span><span class="s2">&quot;Quadrature&quot;</span><span class="p">,</span>
                <span class="n">cell</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span>
                <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">,</span>
                <span class="n">quad_scheme</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Quadrature&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Quadrature&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">VertexDomain</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A subdomain defined in terms of</span>
<span class="sd">    a given set of coordinates.</span>
<span class="sd">    A point that is close to the given coordinates</span>
<span class="sd">    within a given tolerance will be marked as inside</span>
<span class="sd">    the domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Arguments*</span>
<span class="sd">          coords (list)</span>
<span class="sd">            List of coordinates for vertices in reference geometry</span>
<span class="sd">            defining this domains</span>

<span class="sd">          tol (float)</span>
<span class="sd">            Tolerance for how close a pointa should be to the given coordinates</span>
<span class="sd">            to be marked as inside the domain</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="n">dolfin</span><span class="o">.</span><span class="n">SubDomain</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">BaseExpression</span><span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">Expression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for assigning boundary condition according to segmented surfaces</span>
<span class="sd">    Since the base is located at x = a (usually a=0), two classes must be set:</span>
<span class="sd">    One for the y-direction and one for the z-direction</span>

<span class="sd">    Point on the endocardium and epicardium is given and the</span>
<span class="sd">    points on the mesh base is set accordingly.</span>
<span class="sd">    Points that lie on the base but not on the epi- or endoring</span>
<span class="sd">    will be given a zero value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_verts</span><span class="p">,</span> <span class="n">seg_verts</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        *Arguments*</span>
<span class="sd">          mesh: (dolfin.mesh)</span>
<span class="sd">            The mesh</span>

<span class="sd">          u: (dolfin.GenericFunction)</span>
<span class="sd">            Initial displacement</span>

<span class="sd">          mesh_verts (numpy.ndarray or list)</span>
<span class="sd">            Point of endocardial base from mesh</span>

<span class="sd">          seg_verts (numpy.ndarray or list)</span>
<span class="sd">            Point of endocardial base from segmentation</span>

<span class="sd">          sub (str)</span>
<span class="sd">            Either &quot;y&quot; or &quot;z&quot;. The displacement in this direction is returned</span>

<span class="sd">          it (dolfin.Expression)</span>
<span class="sd">            Can be used to incrment the direclet bc</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">sub</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_verts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_seg_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg_verts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_seg_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_seg_verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sub</span> <span class="o">=</span> <span class="n">sub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_it</span> <span class="o">=</span> <span class="n">it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_it</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seg_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_seg_verts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_it</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="c1"># Check if given coordinate is in the endoring vertices</span>
        <span class="c1"># and find the cooresponding index</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">d_intersect</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_intersect</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_intersect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">d_intersect</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">prev_seg_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_seg_verts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Return the displacement in the given direction</span>
            <span class="c1"># Iterated starting from the previous displacemet</span>
            <span class="c1"># to the current one</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">u_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_seg_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">u_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seg_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># value[0] = u_prev + self._it.t*(u_current - u_prev)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># sub == &quot;z&quot;</span>
                <span class="n">u_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_seg_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">u_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seg_verts</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">u_prev</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_it</span><span class="o">.</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_current</span> <span class="o">-</span> <span class="n">u_prev</span><span class="p">)</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">MixedParameter</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;material_parameters&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize Mixed parameter.</span>

<span class="sd">        This will instanciate a function in a dolfin.MixedFunctionSpace</span>
<span class="sd">        consiting of `n` subspaces of the same type as `fun`.</span>
<span class="sd">        This is of course easy for the case when `fun` is a normal</span>
<span class="sd">        dolfin function, but in the case of a `RegionalParameter` it</span>
<span class="sd">        is not that straight forward.</span>
<span class="sd">        This class handles this case as well.</span>


<span class="sd">        :param fun: The type of you want to make a du</span>
<span class="sd">        :type fun: (:py:class:`dolfin.Function`)</span>
<span class="sd">        :param int n: number of subspaces</span>
<span class="sd">        :param str name: Name of the function</span>

<span class="sd">        .. todo::</span>

<span class="sd">           Implement support for MixedParameter with different</span>
<span class="sd">           types of subspaces, e.g [RegionalParamter, R_0, CG_1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please provide a dolin function as argument to MixedParameter&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="p">(</span><span class="n">dolfin</span><span class="o">.</span><span class="n">Function</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">RegionalParameter</span><span class="p">)),</span> <span class="n">msg</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">RegionalParameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="c1"># We can just make a usual mixed function space</span>
        <span class="c1"># with n copies of the original one</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">MixedFunctionSpace</span><span class="p">([</span><span class="n">V</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Create a function assigner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_assigner</span> <span class="o">=</span> <span class="p">[</span><span class="n">FunctionAssigner</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="c1"># Store the original function space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basespace</span> <span class="o">=</span> <span class="n">V</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">RegionalParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meshfunction</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="n">_meshfunction</span>

    <span class="k">def</span> <span class="nf">assign_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign subfunction</span>

<span class="sd">        :param f: The function you want to assign</span>
<span class="sd">        :param int i: The subspace number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basespace</span><span class="p">)</span>
        <span class="n">f_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_assigner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">i</span><span class="p">],</span> <span class="n">f_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RegionalParameter</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A regional paramerter defined in terms of a dolfin.MeshFunction</span>

<span class="sd">    Suppose you have a MeshFunction defined different regions in your mesh,</span>
<span class="sd">    and you want to define different parameters on different regions,</span>
<span class="sd">    then this is what you want.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshfunction</span><span class="p">):</span>

        <span class="c1"># assert isinstance(</span>
        <span class="c1">#     meshfunction, dolfin.MeshFunctionSizet</span>
        <span class="c1"># ), &quot;Invalid meshfunction for regional gamma&quot;</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">meshfunction</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>

        <span class="c1"># FIXME</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">numpy_mpi</span><span class="o">.</span><span class="n">gather_broadcast</span><span class="p">(</span><span class="n">meshfunction</span><span class="o">.</span><span class="n">array</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nvalues</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

        <span class="n">V</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nvalues</span><span class="p">)</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meshfunction</span> <span class="o">=</span> <span class="n">meshfunction</span>

        <span class="c1"># Functionspace for the indicator functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proj_space</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;DG&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Make indicator functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ind_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ind_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_indicator_function</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return linear combination of coefficents</span>
<span class="sd">        and basis functions</span>

<span class="sd">        :returns: A function with parameter values at each segment</span>
<span class="sd">                  specified by the meshfunction</span>
<span class="sd">        :rtype:  :py:class`dolfin.Function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proj_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Space for projecting the scalars.</span>
<span class="sd">        This is a DG 0 space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_space</span>

    <span class="k">def</span> <span class="nf">_make_indicator_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marker</span><span class="p">):</span>

        <span class="n">dofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshfunction</span><span class="o">.</span><span class="n">where_equal</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_proj_space</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">vector</span><span class="p">()[</span><span class="n">dofs</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ind_functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ind_functions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">fun</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">fun</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Henrik Finsberg.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>